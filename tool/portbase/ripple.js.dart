import 'dart:html' as html;
import 'dart:math' as Math;

/// Copyright 2015 Google Inc. All Rights Reserved.
/// 
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
/// 
/// http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

/// Class constructor for Ripple WSK component.
/// Implements WSK component design pattern defined at:
/// https://github.com/jasonmayes/mdl-component-design-pattern
/// param {HTMLElement} element The element that will be upgraded.
class MaterialRipple {

    final element;

    MaterialRipple(this.element);

  // Initialize instance.
  init();
}

/// Store constants in one place so they can be updated easily.
/// enum {string | number}
class _MaterialRippleConstant {
    final String INITIAL_SCALE = 'scale(0.0001, 0.0001)';
    final String INITIAL_SIZE = '1px';
    final String INITIAL_OPACITY = '0.4';
    final String FINAL_OPACITY = '0';
  FINAL_SCALE: ''
}

/// Store strings for class names defined by this component that are used in
/// JavaScript. This allows us to simply change it in one place should we
/// decide to modify at a later date.
/// enum {string}
class _MaterialRippleCssClasses {
    final String RIPPLE_CENTER = 'mdl-ripple--center';
    final String RIPPLE_EFFECT_IGNORE_EVENTS = 'mdl-js-ripple-effect--ignore-events';
    final String RIPPLE = 'mdl-ripple';
    final String IS_ANIMATING = 'is-animating';
    final String IS_VISIBLE = 'is-visible';
}

/// Handle mouse / finger down on element.
/// param {Event} event The event that fired.
/// MaterialRipple.prototype.downHandler_ = function(event) {
void _downHandler(final html.Event event) {

  _rippleElement.classes.add(_cssClasses.IS_VISIBLE);

  if (event.type == 'mousedown' && _ignoringMouseDown) {
    _ignoringMouseDown = false;

  } else {
    if (event.type == 'touchstart') {
      _ignoringMouseDown = true;
    }

    final frameCount = getFrameCount();
    if (frameCount > 0) {
      return;
    }
    setFrameCount(1);

    final bound = event.currentTarget.getBoundingClientRect();

    final x;

    final y;
    // Check if we are handling a keyboard click.
    if (event.clientX == 0 && event.clientY == 0) {
      x = Math.round(bound.width / 2);
      y = Math.round(bound.height / 2);

    } else {

      final clientX = event.clientX ? event.clientX : event.touches[0].clientX;

      final clientY = event.clientY ? event.clientY : event.touches[0].clientY;
      x = Math.round(clientX - bound.left);
      y = Math.round(clientY - bound.top);
    }
    setRippleXY(x, y);
    setRippleStyles(true);
    window.requestAnimFrame(animFrameHandler);
  }
}

/// Handle mouse / finger up on element.
/// param {Event} event The event that fired.
/// MaterialRipple.prototype.upHandler_ = function(event) {
void _upHandler(final html.Event event) {

  // Don't fire for the artificial "mouseup" generated by a double-click.
  if (event && event.detail != 2) {
    _rippleElement.classes.remove(_cssClasses.IS_VISIBLE);
  }
}

/// Initialize element.
/// MaterialRipple.prototype.init = /*function*/ () {
void init() {

  if (element != null) {

    final recentering =
        element.classes.contains(_cssClasses.RIPPLE_CENTER);
    if (!element.classes.contains(
        _cssClasses.RIPPLE_EFFECT_IGNORE_EVENTS)) {
      _rippleElement = element.querySelector('.' +
          _cssClasses.RIPPLE);
      _frameCount = 0;
      _rippleSize = 0;
      _x = 0;
      _y = 0;

      // Touch start produces a compat mouse down event, which would cause a
      // second ripples. To avoid that, we use this property to ignore the first
      // mouse down after a touch start.
      _ignoringMouseDown = false;

      if (_rippleElement) {

        final bound = element.getBoundingClientRect();
        _rippleSize = Math.sqrt(bound.width * bound.width +
            bound.height * bound.height) * 2 + 2;
        _rippleElement.style.width = _rippleSize + 'px';
        _rippleElement.style.height = _rippleSize + 'px';
      }

      element.addEventListener('mousedown', _downHandler);
      element.addEventListener('touchstart',
          _downHandler);

	// .addEventListener('mouseup', -- .onMouseUp.listen(<MouseEvent>);
      element.onMouseUp.listen( _upHandler);

	// .addEventListener('mouseleave', -- .onMouseLeave.listen(<MouseEvent>);
      element.onMouseLeave.listen( _upHandler);
      element.addEventListener('touchend', _upHandler);

	// .addEventListener('blur', -- .onBlur.listen(<Event>);
      element.onBlur.listen( _upHandler);

      getFrameCount = /*function*/ () {
        return _frameCount;
      }

      setFrameCount = function(fC) {
        _frameCount = fC;
      }

      getRippleElement = /*function*/ () {
        return _rippleElement;
      }

      setRippleXY = function(newX, newY) {
        _x = newX;
        _y = newY;
      }

      setRippleStyles = function(start) {
        if (_rippleElement != null) {

          final transformString;

          final scale;

          final size;

          final offset = 'translate(' + _x + 'px, ' + _y + 'px)';

          if (start) {
            scale = _constant.INITIAL_SCALE;
            size = _constant.INITIAL_SIZE;

          } else {
            scale = _constant.FINAL_SCALE;
            size = _rippleSize + 'px';
            if (recentering) {
              offset = 'translate(' + bound.width / 2 + 'px, ' +
                bound.height / 2 + 'px)';
            }
          }

          transformString = 'translate(-50%, -50%) ' + offset + scale;

          _rippleElement.style.webkitTransform = transformString;
          _rippleElement.style.msTransform = transformString;
          _rippleElement.style.transform = transformString;

          if (start) {
            _rippleElement.classes.remove(_cssClasses.IS_ANIMATING);

          } else {
            _rippleElement.classes.add(_cssClasses.IS_ANIMATING);
          }
        }
      }

      animFrameHandler = /*function*/ () {
        if (_frameCount-- > 0) {
          window.requestAnimFrame(animFrameHandler);

        } else {
          setRippleStyles(false);
        }
      }
    }
  }
}

// The component registers itself. It can assume componentHandler is available
// // in the global scope.

// componentHandler.register({
//   constructor: MaterialRipple,
//   classAsString: 'MaterialRipple',
//   cssClass: 'mdl-js-ripple-effect'
// });
